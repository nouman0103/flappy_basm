[org 0x0100]

jmp start

bird1: db 12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,12h,12h,12h,5Ch,5Ch,5Ch,5Ch,12h,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,5Ch,5Ch,5Ch,12h,12h,2Ah,2Ah,2Ah,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,0h,0h,5Ch,12h,12h,12h,12h,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,0h,0h,5Ch,12h,12h,5Ch,5Ch,5Ch,42h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,12h,5Ch,5Ch,5Ch,5Ch,5Ch,5Ch,12h,12h,5Ch,5Ch,5Ch,5Ch,42h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,5Ch,12h,12h,12h,5Ch,5Ch,5Ch,5Ch,5Ch,42h,12h,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,12h,12h,12h,12h,12h,12h,12h,42h,5Ch,5Ch,5Ch,5Ch,5Ch,12h,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,12h,12h,12h,12h,12h,12h,12h,12h,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,12h,29h,29h,29h,29h,29h,29h,29h,29h,29h,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,29h,29h,04h,04h,04h,04h,04h,12h,12h,12h,12h,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,12h,12h,29h,29h,29h,29h,29h,29h,29h,29h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h
bird2: db 12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,12h,12h,12h,5Ch,5Ch,5Ch,5Ch,12h,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,5Ch,5Ch,5Ch,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,0h,0h,5Ch,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,0h,0h,5Ch,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,12h,5Ch,5Ch,5Ch,5Ch,5Ch,5Ch,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,5Ch,5Ch,5Ch,5Ch,12h,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,12h,12h,42h,5Ch,5Ch,5Ch,5Ch,5Ch,12h,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,12h,12h,5Ch,5Ch,5Ch,5Ch,5Ch,42h,12h,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,5Ch,5Ch,5Ch,5Ch,42h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,12h,29h,29h,29h,29h,29h,29h,29h,29h,29h,12h,12h,12h,12h,12h,12h,12h,2Ah,2Ch,2Ch,2Ch,2Ch,2Ch,2Ch,2Ah,12h,29h,29h,04h,04h,04h,04h,04h,12h,12h,12h,12h,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,2Ah,12h,12h,29h,29h,29h,29h,29h,29h,29h,29h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h

ground: db 0xEE,48h,31h,31h,31h,31h,31h,79h,2Bh,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h
pipe: db 0xEE,0xEE,60h,49h,0xEE,0Ah,0xEE,0Ah,2Fh,60h,60h,60h,60h,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,2Fh,0xEE,2Fh,2Fh,0xEE,2Fh,02h,02h,79h,79h,0xBF,0xEE,0xEE
scoreBoard: db 43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,36h,36h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,36h,36h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,36h,36h,36h,36h,36h,43h,36h,36h,36h,36h,43h,36h,36h,36h,36h,36h,43h,36h,36h,36h,36h,36h,43h,36h,36h,36h,36h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,36h,36h,69h,69h,69h,43h,36h,36h,69h,69h,43h,36h,36h,69h,36h,36h,43h,36h,36h,69h,36h,36h,43h,36h,36h,69h,69h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,36h,36h,2Bh,2Bh,2Bh,43h,36h,36h,2Bh,2Bh,43h,36h,36h,2Bh,36h,36h,43h,36h,36h,2Bh,36h,69h,43h,36h,36h,2Bh,43h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,36h,36h,36h,36h,36h,43h,36h,36h,43h,43h,43h,36h,36h,43h,36h,36h,43h,36h,36h,36h,36h,2Bh,43h,36h,36h,36h,36h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,69h,69h,69h,36h,36h,43h,36h,36h,43h,43h,43h,36h,36h,43h,36h,36h,43h,36h,36h,69h,36h,36h,43h,36h,36h,69h,69h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,2Bh,2Bh,2Bh,36h,36h,43h,36h,36h,43h,43h,43h,36h,36h,43h,36h,36h,43h,36h,36h,2Bh,36h,36h,43h,36h,36h,2Bh,43h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,36h,36h,36h,36h,36h,43h,36h,36h,36h,36h,43h,36h,36h,36h,36h,36h,43h,36h,36h,43h,36h,36h,43h,36h,36h,36h,36h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,69h,69h,69h,69h,69h,43h,69h,69h,69h,69h,43h,69h,69h,69h,69h,69h,43h,69h,69h,43h,69h,69h,43h,69h,69h,69h,69h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,2Bh,2Bh,2Bh,2Bh,2Bh,43h,2Bh,2Bh,2Bh,2Bh,43h,2Bh,2Bh,2Bh,2Bh,2Bh,43h,2Bh,2Bh,43h,2Bh,2Bh,43h,2Bh,2Bh,2Bh,2Bh,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,36h,36h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,36h,36h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,36h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,69h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,43h,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh,2Bh
birdy: dw 30
pipesX: dw 319,  500
pipesY: dw 50 ,   20
leftOverPipeWidth: dw 0
leftOverPipeY: dw 0
boolDrawBottomPipe: dw 0
intBottomPipeStart: dw 0
intPipeEndX: dw 0
intBirdBottomY: dw 0
velocityUp: dw 6
velocityUpCounter: dw 0
positionUpCounter: dw 2
velocityDown: dw 5
velocityDownCounter: dw 7
positionDownCounter: dw 5
birdCounter: dw 30
boolCollided: dw 0
score: dw 0
scoreCounter: dw 0
sound: dw 0x149
isMenu: dw 1
boolGameOver: dw 0
StartText: db "Press spacebar to start"
ExitText: db "Press Q to exit"
GameOverText: db "Game Over"
GameRestartText: db "Press R to restart"
boolFirstPipe: dw 0
SPACE_KEY equ 20h
;====================================
defSleep:
pusha
mov cx, 0; keep it 0
mov dx, 0x3A98 ; 5000 microseconds
mov ah, 86h ; function 86h
int 15h ; call interrupt 15h
popa
ret

;====================================
defDrawMenuTexts:
push bp
mov bp, sp
pusha

mov al, 1
mov bh, 0
mov bl, 0x05
mov cx, 23 ; calculate message size.
mov dl, 10
mov dh, 10
push cs
pop es
mov bp, StartText
mov ah, 13h
int 10h

mov dl, 13
mov dh, 12
mov cx, 15 ; calculate message size.
mov bp, ExitText
int 10h

push 35h ; background color
push 250 ; width
push 80 ; y Cordinate
push 40 ; x Cordinate
call defSetTextBackground
push 35h ; background color
push 250 ; width
push 96 ; y Cordinate
push 50 ; x Cordinate
call defSetTextBackground


popa
pop bp
ret
;====================================
defSetTextBackground:
push bp
mov bp, sp
pusha

mov cx, [bp+4]; x Cordinate
mov dx, [bp+6]; y Cordinate
mov bx, cx
add bx, [bp+8]; x Cordinate + width

checkAndReplace:
mov ah, 0Dh
int 10h
cmp al, 00h
jne skipReplace
mov ah, 0Ch
mov al, [bp+10]
int 10h
skipReplace:
inc cx
cmp cx, bx
jb checkAndReplace
inc dx
mov cx, [bp+4]
mov ax, [bp+6]
add ax, 8
cmp dx, ax
jb checkAndReplace

popa
pop bp
ret 8
;====================================
defDrawGameOver:
push bp
mov bp, sp
pusha

mov al, 1
mov bh, 0
mov bl, 0x28
mov cx, 9 ; calculate message size.
mov dl, 15
mov dh, 20
push cs
pop es
mov bp, GameOverText
mov ah, 13h
int 10h

push 43h ; background color
push 250 ; width
push 160 ; y Cordinate
push 120 ; x Cordinate
call defSetTextBackground


mov cx, 18 ; calculate message size.
mov dl, 8
mov dh, 24
mov bp, GameRestartText
int 10h

push 43h ; background color
push 250 ; width
push 192 ; y Cordinate
push 50 ; x Cordinate
call defSetTextBackground

popa
pop bp
ret
;====================================
defDrawSky: ; Draw a entire row of sky
mov al,35h
mov ah,0ch
mov cx,0
drawSky:
int 10h
inc cx
cmp cx,320
jb drawSky
ret
;====================================
defDrawGround: ; Draw a entire row of ground
mov byte al, [bx]
mov cx,0
drawGround:
int 10h
inc cx
cmp cx,320
jb drawGround
ret
;=====================================
drawBackground:
pusha
mov dx, 0
skyLoop:
call defDrawSky
inc dx
cmp dx, 150
jb skyLoop
mov bx, ground
groundLoop:
call defDrawGround
inc bx
inc dx
cmp dx, 200
jb groundLoop
popa
ret
;=====================================
printnum:
push bp
mov bp, sp
pusha 

cmp word [scoreCounter], 0
jne skipPrint
mov word [scoreCounter], 30
cmp word [isMenu], 1
je skipPrint
inc word [score]

mov ax, [score] ; load number in ax
mov bx, 10 ; use base 10 for division
mov cx, 0 ; initialize count of digits
nextdigit:
mov dx, 0 ; zero upper half of dividend
div bx ; divide by 10
add dl, 0x30 ; convert digit into ascii value
push dx ; save ascii value on stack
inc cx ; increment count of values
cmp ax, 0 ; is the quotient zero
jnz nextdigit ; if no divide it again

checkCount:
cmp cx, 3 ; is the count 3
jae print3 ; if yes print 3 digits
push '0' ; if no print leading zero
inc cx ; increment count of values
jmp checkCount
print3:
mov bh, 0
mov bl, 0x36
nextpos:
mov ah, 2
mov dh, 22
mov dl, 23
sub dl, cl
push cx
mov cx, 1
int 10h
pop cx
pop ax
mov ah, 0Ah
int 10h
loop nextpos ; repeat for all digits on stack
skipPrint:
dec word [scoreCounter]
popa
pop bp
ret
;=====================================
;Draw Flappy bird, Input: 1 dw element, y Cordinate
defDrawBird:
push bp
mov bp, sp
pusha

mov cx, 40 ; x Cordinate
mov bx, [bp+4] ; y Cordinate
mov dx, bx ; y Cordinate
add bx, 15 ; y Cordinate + 15
mov word [intBirdBottomY], bx ; Save y Cordinate

cmp word [birdCounter], 15
ja selectBird1
mov bx, bird2 ; point bx to bird2
cmp word [birdCounter], 0
ja startDrawBird
mov word [birdCounter], 30
jmp startDrawBird
selectBird1:
mov bx, bird1 ; point bx to bird1

startDrawBird:
dec word [birdCounter]
sub dx,1
mov ah,0ch

mov al,35h
drawTopSky:
int 10h
inc cx
cmp cx,65
jb drawTopSky

mov cx, 40
inc dx

drawBird:
mov byte al, [bx] ; Get pixel color
int 10h ; Draw pixel
inc cx ; x Cordinate + 1
inc bx ; point bx to next pixel
cmp cx, 65 ; Check if x Cordinate is 65
jb drawBird ; If x Cordinate is less than 65, draw another pixel
inc dx ; y Cordinate + 1
mov cx, 40 ; x Cordinate = 40
cmp dx, [intBirdBottomY] ; Check if y Cordinate is equal to y Cordinate
jb drawBird ; If y Cordinate is less than y Cordinate + 15, draw another pixel

mov al,35h
drawBottomSky:
int 10h
inc cx
cmp cx,65
jb drawBottomSky

popa 
pop bp
ret 2

;=====================================
setFallDown:
mov word [velocityDown], 5
mov word [velocityDownCounter], 7
mov word [positionDownCounter], 5
ret

moveBird:
pusha; Push all registers to stack
mov ah,01h ; Get keyboard input
int 16h ; Get keyboard input
jz moveBirdUp
mov ah,00h ; Get keyboard input
int 16h ; Get keyboard input
cmp al,SPACE_KEY ; Check if keyboard input is SPACE_KEY
jne moveBirdUp ; If keyboard input is not SPACE_KEY, jump to moveBirddown
call playSound
mov word [velocityUp], 0
mov word [positionUpCounter], 0

call setFallDown

cmp word [isMenu], 1
jne moveBirdUp
call drawBackground
call defDrawScoreBoard
mov word [isMenu], 0


moveBirdUp:
cmp word [isMenu], 1
je endMoveBird

cmp word [velocityUp], 6
je moveBirdDown
cmp word [positionUpCounter], 2
ja skipMoveUp
dec word [birdy]
mov bx, [velocityUp]
inc bx
mov [positionUpCounter], bx
skipMoveUp:
cmp word [velocityUpCounter], 0
jne endUpMove
inc word [velocityUp]
mov word [velocityUpCounter], 7
endUpMove:
dec word [positionUpCounter]
dec word [velocityUpCounter]
jmp endMoveBird

moveBirdDown:
cmp word [positionDownCounter], 0
jne skipMoveDown
inc word [birdy]
mov bx, [velocityDown]
mov [positionDownCounter], bx

skipMoveDown:
cmp word [velocityDown], 0
je endMoveBird
cmp word [velocityDownCounter], 0
jne endDownMove
dec word [velocityDown]
mov word [velocityDownCounter], 7
endDownMove:
dec word [velocityDownCounter]
dec word [positionDownCounter]



endMoveBird:

popa ; Pop all registers from stack
ret ; Return to mainLoop
;=====================================
defDrawScoreBoard:
push bp
mov bp, sp
pusha

mov cx, 126 ; x Cordinate
mov dx, 171 ; y Cordinate
mov ah, 0ch ; Function
mov bx, scoreBoard ; Point bx to scoreBoard

drawScoreBoard:
mov al, [bx] ; Get pixel color
int 10h ; Draw pixel
inc cx ; x Cordinate + 1
inc bx ; point bx to next pixel
cmp cx, 187 ; x cordinate + 61
jb drawScoreBoard
inc dx ; y Cordinate + 1
mov cx, 126 ; x Cordinate
cmp dx, 189 ; y Cordinate + 18
jb drawScoreBoard

popa
pop bp
ret
;=====================================
defDrawPipe:
push bp
mov bp, sp
pusha

mov cx, [bp+4] ; x Cordinate
mov dx, 0 ; y Cordinate


mov ah, 0ch ; Function
mov bx, [bp+6]
mov word [intBottomPipeStart], bx ; Save y Cordinate
add word [intBottomPipeStart], 55
mov word [boolDrawBottomPipe], 0 ; boolDrawBottomPipe = 0
mov word [intPipeEndX], cx
add word [intPipeEndX], 40

mov bx, pipe

cmp word [bp+8], 1
je drawTopPipe
cmp word [leftOverPipeWidth], 0
jbe endDrawPipe
mov cx, [leftOverPipeWidth]
mov word [intPipeEndX], cx
mov cx, 40
sub cx, [leftOverPipeWidth]
add bx, cx
mov cx, 0
dec word [leftOverPipeWidth]

drawTopPipe:
cmp dx, [bp+6] ; Check if y Cordinate is equal to y Cordinate + 150
je drawBorder
cmp dx, [intBottomPipeStart]
je drawBorder
mov byte al, [bx]
jmp colorSelected
drawBorder:
mov al, 0xEE
colorSelected:
cmp cx, 320
jae endDrawPipe
cmp cx , 0
jb endDrawPipe
int 10h ; Draw pixel
skipPipe:
inc dx ; x Cordinate + 1
cmp dx, [bp+6]
jbe drawTopPipe
cmp dx, [intBottomPipeStart]
ja notSkip
add dx, 54
notSkip:
cmp dx, 150
jb drawTopPipe

inc cx
mov dx, 0
inc bx
cmp cx, [intPipeEndX]
jb drawTopPipe


endDrawPipe:
popa 
pop bp
ret 6

;=====================================
movePipe:
push bp
mov bp, sp
pusha
mov bx, [bp+4] ; Ref to Address of pipesX
dec word [bx] ; Decrement x Cordinate
mov cx, [bx] ; x Cordinate
add cx,41 ; Last x Cordinate + 41
cmp cx, 320
jge adjustX
jmp continueDrawing ; Continue drawing pipe
adjustX:
sub word cx, 320
continueDrawing:
mov dx,0 ; y Cordinate
mov al,35h
mov ah,0ch
mov si,[bp+6] ; Ref to Address of pipesY
drawLastColumnSky:
int 10h
cmp dx, [si] ; y Cordinate
jne continueDrawingSky
cmp cx,41 ; x Cordinate
jb continueDrawingSky
add dx, 55
jmp drawLastColumnSky
continueDrawingSky:
inc dx
cmp dx,150
jb drawLastColumnSky

;Check if pipe is out of screen
sub cx,41 ; Last x Cordinate
cmp cx,0
jne endMovePipe
cmp word [pipesX] , 0
jne endMovePipeContinue
mov word [boolFirstPipe], 1
endMovePipeContinue:
mov word [leftOverPipeWidth], 40
mov cx, [si]
mov word [leftOverPipeY], cx
mov word [bx], 320
push word [bp+6] ; Ref to Address of pipesY
call generateRandomNumber

endMovePipe:
popa
pop bp
ret 2
;=====================================
defCollided:
push ax
call playSound
mov word [boolGameOver], 1
call defDrawGameOver
waitForKey:
mov ah,00
int 16h
cmp al, 'r'
jne waitForKey
mov word [isMenu], 1
mov word [score], 0
mov word [scoreCounter], 0
mov word [birdy], 30
mov word [pipesX], 319
mov word [pipesX+2], 500
mov word [pipesY], 50
mov word [pipesY+2], 20
mov word [leftOverPipeWidth], 0
mov word [leftOverPipeY], 0
mov word [boolDrawBottomPipe], 0
mov word [intBottomPipeStart], 0
mov word [intPipeEndX], 0
mov word [velocityUp], 6
mov word [velocityUpCounter], 0
mov word [positionUpCounter], 2
mov word [velocityDown], 5
mov word [velocityDownCounter], 7
mov word [positionDownCounter], 5
mov word [birdCounter], 30
mov word [boolCollided], 0
mov word [score], 0
mov word [scoreCounter], 0
mov word [boolGameOver], 0
mov word [boolFirstPipe], 0

call drawBackground
call defDrawScoreBoard
call defDrawMenuTexts

pop ax
ret

;=====================================
defCheckPipeCollisions:
push bp
mov bp, sp
pusha


; check 1, pipeX > 40 && pipeX < 65
cmp word [bp+6], 40
jb checkx2
cmp word [bp+6], 65
ja checkx2
jmp checkY
checkx2:
; check 2, pipeX < 40
cmp word [bp+6], 40
ja clear
jmp checkY

checkY:
; check Y, pipeY < birdY && pipeY + 55 > birdY

mov dx, [bp+4]
mov bx, [birdy]
cmp dx, bx
ja collided
add dx, 55
add bx, 15
cmp dx, bx
ja clear

collided:
call defCollided


clear:
popa
pop bp
ret 4
;=====================================

defCheckCollisions:
push bp
mov bp, sp
pusha

; check for collision with ground
mov dx, [birdy] ; y Cordinate
cmp dx, 0
ja topCollisionClear
mov word [velocityUp], 6
call setFallDown
mov word [birdy], 1

topCollisionClear:
add dx, 15
cmp dx, 150
jb groundCollisionClear
call defCollided
groundCollisionClear:

push word [pipesX]
push word [pipesY]
call defCheckPipeCollisions

push word [pipesX+2]
push word [pipesY+2]
call defCheckPipeCollisions

popa
pop bp
ret

;=====================================
generateRandomNumber:
push bp ; Push bp to stack
mov bp, sp ; Move sp to bp
pusha ; Push all registers to stack
mov ah,0 ; Function 0
int 1ah ; Get system time
mov ax,dx ; Move dx to ax
mov bx,60 ; Move 60 to bx
mov dx,0 ; Move 0 to dx
div bx ; Divide ax by bx
mov bx, [bp+4] ; Move address of variable to bx
mov word [bx], dx ; Move dx to variable
add word [bx], 20 ; Add 20 to variable
popa ; Pop all registers from stack
pop bp ; Pop bp from stack
ret 2 ; Return to mainLoop

;=====================================
ChibiSound:   ;NVTTTTTT	Noise Volume Tone (N=1 highest pitch)
	
	cmp al,0
	je ChibiSound_Silent
	
	push ax
		mov ah,al
				;   CCAAMMMS  C=Counter select,  A=counter Access
							;M=counter Mode, S=counter Style
		mov al, 10110110b   ;M=3 - square wave, AA=3 Write LH Bytes to 42h
							;C=2 - Counter 2 select
		out 43h, al     
		
	
		and ah,00111111b	;Pitch bits
		
		xor al,al
		mov cl,2			;shift pitch
		ror ax,cl
				
		out 42h, al       	;L Byte - 0042 - counter 2
		mov al, ah  		;Send High Byte
		out 42h, al 		;H Byte - 0042 - counter 2
		
		
		in al, 61h      	;Get status of KB controller port B 
			;  R---PPST 	 R=Reset P= parity checks S=Speaker 
							;T=speaker Timer 
		or al, 00000011b	;Turn on the speaker   
		out 61h, al       	;Update KB controller port B
		and al,11111101b
		mov ah,al			;Store 'Off' setting for later
	pop bx
	
	mov cx,4000h			;Quiet tone length
	
	test bl,10000000b
	jnz ChibiSound_DoNoise	;Turn on noise?
	
	test bl,01000000b
	jnz ChibiSound_DoLoud
	
ChibiSound_Quiet:		
	
	loop ChibiSound_Quiet	;Wait for quiet tone
	jmp ChibiSound_Silent	;Turn off tone
	
ChibiSound_DoNoise:	
	mov cx,2000h			;Noise lengyh (2000=loud 1000=quiet)
		
	test bl,01000000b		;Volume bit
	
	mov bx,0010000001101010b	;Noise pattern
	
	jnz ChibiSound_Noise
	ror cx,1				;Quiet noise (1000h)
	
ChibiSound_Noise:
	ror bx,1				;Cycle noise pattern
	mov al,bl
	xor al,cl				;add in CH/CL
	add al,ch
	and al,00000010b		;Get one bit
	or al,ah				;Turn into a sound on/off toggle
	out 61h, al 
	loop ChibiSound_Noise
	
ChibiSound_Silent:	
	in al, 61h 			;Get status of KB controller port B 
		 ;  R---PPST 	 R=Reset P= parity checks S=Speaker 
							;T=speaker Timer 
	and al, 11111100b  	;Turn off the speaker 
	out 61h, al       	;Update KB controller port B
ChibiSound_DoLoud:
	ret
	
;=====================================
playSound:
push word [sound] 
		Call ChibiSound
pop ax
endPlaySound:
ret
;=====================================
mainLoop:

call moveBird
call defCheckCollisions
push word [birdy]
call defDrawBird

cmp word [isMenu], 1
je skipCauseMenu

push pipesY ; y Cordinate address of pipe
push pipesX; x Cordinate address of pipe    
call movePipe
push pipesY+2 ; y Cordinate address of pipe
push pipesX+2 ; x Cordinate address of pipe
call movePipe

push 1
push word [pipesY] ; x Cordinate of pipe
push word [pipesX] ; y Cordinate of pipe
call defDrawPipe
push 1
push word [pipesY+2] ; x Cordinate of pipe
push word [pipesX+2] ; y Cordinate of pipe
call defDrawPipe
cmp word [boolFirstPipe], 1
jne skipCauseMenu
push 0
push word [leftOverPipeY]
push 0
call defDrawPipe

skipCauseMenu:

call printnum

cmp word [isMenu], 1
jne mainLoop
call defSleep
jmp mainLoop

start:

mov ah, 0
mov al, 13h
int 10h

call drawBackground
call defDrawScoreBoard
call defDrawMenuTexts
jmp mainLoop

mov ax, 0x4c00
int 21h
